.TH tntnet.xml 8 "2006\-07\-23" Tntnet "Tntnet users guide"
.SH NAME
.PP
tntnet.xml \- configuration file for 
.BR tntnet (8)
.SH DESCRIPTION
.PP
Tntnet is configured using a xml file. The name of the file is \fItntnet.xml\fP. The
root node of \fItntnet.xml\fP should be \fB\fCtntnet\fR while it is not checked. Most of
the settings are just single values. They are described here in alphabetical
order.
.SH SETTINGS
.PP
This section describes the variables, used by Tntnet (8).
.TP
\fB\fC<AccessLog>*filename*</AccessLog>\fR
Writes a log entry for each request in a common format. This format is
compatible with most log file analyze systems for http servers.
.TP
The log file has the fields:
    \fB\fCpeer-ip\fR \- \fB\fCusername\fR [\fB\fCtime\fR] "\fB\fChttp-method\fR \fB\fCquery-string\fR HTTP/\fB\fCmajor-version\fR.\fB\fCminor-version\fR" \fB\fChttp-return-code\fR \fB\fCcontent-size\fR "\fB\fCreferer\fR" "\fB\fCuser-agent\fR"
.IP
The \fB\fCusername\fR, \fB\fCreferer\fR and \fB\fCuser-agent\fR may be '\-' when the value is not
available. Also the \fB\fCcontent-size\fR can be empty in some cases.
.IP
\fIExample\fP
.PP
.RS
.nf
<AccessLog>/var/log/tntnet/access.log</AccessLog
.fi
.RE
.PP
\fB\fC<BufferSize>*bytes*</BufferSize>\fR
.IP
Specifies the number of bytes sent in a single system\-call. This does not
limit anything in application\-level. It does not affect e.g. savepoints or
exception\-handling. Component\-output is collected completely and then passed
in chunks of BufferSize bytes to the operating system.
.IP
The default value is 16384.
.PP
\fB\fC<comppath><entry>*path1*</entry></comppath>\fR
.IP
\fB\fCcomppath\fR specifies, where tntnet should search for webapplications. Tntnet
searches first in the current directory and then in each directory, you
specify here, until a library is found. You can repeat the directive as many
times as desired to add more entries. If it is not found, the next
MapUrl\-entry is tried.
.IP
\fIExample\fP
.PP
.RS
.nf
<comppath>
  <entry>/usr/local/lib/tntnet</entry>
  <entry>/usr/local/share/tntnet</entry>
</comppath>
.fi
.RE
.PP
\fB\fC<chroot>*directory*</chroot>\fR
.IP
Does a 
.BR chroot (2)-system 
call on startup, which locks the process into the directory at system\-level.
.IP
\fIExample\fP
.PP
.RS
.nf
<chroot>/var/tntnet</chroot>
.fi
.RE
.PP
\fB\fC<daemon>*0|1*</daemon>\fR
.IP
If this flag is set to 1, Tntnet forks at startup and terminates the
parent\-process on successful initialization.
.PP
\fB\fC<dir>*directory*</dir>\fR
.IP
Changes the current working directory of the process on startup.
.IP
\fIExample\fP
.PP
.RS
.nf
<dir>/var/tntnet</dir>
.fi
.RE
.PP
\fB\fC<enableCompression>*yes|no*</enableCompression>\fR
.IP
Specifies, if Tntnet should use gzip\-compression at http\-level. By default
Tntnet use compression. A http\-client like a web browser can send a header
"Accept\-Encoding", to tell Tntnet, that it would accept compressed data.
Tntnet then can decide, if it use compression. When the body is complete,
Tntnet tries to compress the body. If the data can be compressed by more than
10%, Tntnet sends this compressed data. With this flag, this feature can be
turned off.
.IP
Compression slows down processing but reduces the network\-load. Normally the
size of html\-pages can be compressed by about 70%, while Tntnet slows down by
up to 30%.
.IP
\fIExample\fP
.PP
.RS
.nf
<enableCompression>no</enableCompression>
.fi
.RE
.PP
\fB\fC<errorLog>*filename*</errorLog>\fR
.IP
Redirects stderr to the specified file when tntnet runs as a daemon. If
ErrorLog is not set stderr is redirected to /dev/null.
.IP
\fIExample\fP
.PP
.RS
.nf
<errorLog>/var/log/tntnet/error.log</errorLog>
.fi
.RE
.PP
\fB\fC<group>*unix-group-id*</group>\fR
.IP
Changes the group under which tntnet runs.
.IP
The user is changes using the system call 
.BR setgid (2), 
which is only allowed,
when tntnet starts as root user.
.IP
\fIExample\fP
.PP
.RS
.nf
<group>tntnet-group</group>
.fi
.RE
.PP
\fB\fC<keepAliveTimeout>*milliseconds*</keepAliveTimeout>\fR
.IP
Sets the timeout for keep\-alive requests.
.IP
Tntnet tries to do keep\-alive\-requests wherever possible. This has the effect,
that tntnet can receive multiple requests within a single tcp\-connection. The
connection times out after KeepAliveTimeout milliseconds. The timeout defaults
to 15000ms.
.IP
\fIExample\fP
.PP
.RS
.nf
<keepAliveTimeout>300000</keepAliveTimeout>
.fi
.RE
.PP
\fB\fC<keepAliveMax>*number*</keepAliveMax>\fR
.IP
Sets the maximum number of request per tcp\-connection. This defaults to 100.
.IP
\fIExample\fP
.PP
.RS
.nf
<keepAliveTimeout>10</keepAliveTimeout>
.fi
.RE
.PP
\fB\fC<listeners>*listener definition*</listeners>\fR
.IP
Specifies, on which local interfaces tntnet waits for connections. There can
be more than one Listen\-directives, in which case tntnet waits on every
address.
.IP
See separate section \fIListeners\fP
.PP
\fB\fC<logging>*listener definition*</logging>\fR
.IP
Configures logging. See separate section \fIlogging\fP
.PP
\fB\fC<listenRetry>*number*</listenRetry>\fR
.IP
On startup Tntnet calls listen on the specified port. When the systemcall
returns with an error, Tntnet tries again and fails after the specified number
of attempts.
.IP
The default number is 5.
.IP
\fIExample\fP
.PP
.RS
.nf
<listenRetry>10</listenRetry>
.fi
.RE
.PP
\fB\fC<listenBacklog>*number*</listenBacklog>\fR
.IP
The system\-call 
.BR listen (3p) 
needs a parameter backlog, which specifies, how
many pending connections the operating\-system should queue before it starts to
ignore new request. The value is configurable here.
.IP
The default value is 16.
.IP
\fIExample\fP
.PP
.RS
.nf
<ListenBacklog>64</ListenBacklog>
.fi
.RE
.PP
\fB\fC<mapUrl>*urlmappings*</mapUrl>\fR
.IP
This is the most important setting for tntnet. It specifies, which components
schould be called on which urls.
.IP
For details see the section \fIUrlmapping\fP.
.PP
\fB\fC<maxUrlMapCache>*number*</maxUrlMapCache>\fR
.IP
Mapping urls to components is done using regular expressions. Executing these
expressions is quite expensive while the number of different urls is quite
limited in typical web applications. Hence tntnet caches the results.
.IP
The caching algorithm is very simple. Tntnet just collects the results in a
map. When the maximum size of the list is reached, it is cleared. This makes
management of the cache very cheap.
.IP
This setting sets the maximum number of entries in the map.
.IP
If you see frequently a warning message, that the cache is cleared, you may
consider increasing the size.
.IP
The default value is 8192.
.IP
\fIExample\fP
.PP
.RS
.nf
<maxUrlMapCache>32768</maxUrlMapCache>
.fi
.RE
.PP
\fB\fC<maxRequestSize>*number*</maxRequestSize>\fR
.IP
This directive limits the size of the request. After \fInumber\fP Bytes the
connection is just closed. This prevents denial\-of\-service\-attacks through
long requests. Every request is read into memory, so it must fit into it.
Bear in mind, that if you use file\-upload\-fields a request might be larger
than just a few bytes.
.IP
The value defaults to 0, which means, that there is no limit at all.
.IP
\fIExample\fP
.PP
.RS
.nf
<maxRequestSize>65536</maxRequestSize>
.fi
.RE
.PP
\fB\fC<maxRequestTime>*seconds*</maxRequestTime>\fR
.IP
In daemon mode tntnet has a watchdog, which restarts tntnet when the maximum
request time is exceeded. This happens, when a request is in a endless loop or
otherwise hangs. Restarting tntnet looses all active sessions and the
currently running requests. Therefore the timeout should be well long enough
for the longes request.
.IP
The default value is 600 seconds, which is normally much longer than a http
request should run. If the Timeout is set to 0, the watchdog is deactivated.
.IP
\fIExample\fP
.PP
.RS
.nf
<maxRequestTime>1200</maxRequestTime>
.fi
.RE
.PP
\fB\fC<minThreads>*number*</minThreads>\fR
.IP
Tntnet uses a dynamic pool of worker\-threads, which wait for incoming
requests. MinThreads specifies, how many worker threads there have to be. This
defaults to 5.
.IP
\fIExample\fP
.PP
.RS
.nf
<minThreads>10</minThreads>
.fi
.RE
.PP
\fB\fC<minCompressSize>*number*</minCompressSize>\fR
.IP
Http\-compression for replies smaller than this are not compressed at all.
.IP
The default value for this is 1024.
.IP
\fIExample\fP
.PP
.RS
.nf
<minCompressSize>256</minCompressSize>
.fi
.RE
.PP
\fB\fC<maxThreads>*number*</maxThreads>\fR
.IP
Tntnet uses a dynamic pool of worker\-threads, which wait for incoming
requests. \fB\fCmaxThreads\fR limits the number of threads.
.IP
The default is 100.
.IP
\fIExample\fP
.PP
.RS
.nf
<maxThreads>200</maxThreads>
.fi
.RE
.PP
\fB\fC<pidFile>*filename*</pidFile>\fR
.IP
When run in daemon\-mode, tntnet writes the process\-id of the monitor\-process
to filename. When the monitor\-process is deactivated, the pid of the
worker\-process is written. This ensures, that sending a sigkill to the the
stored process\-id stops tntnet.
.IP
\fIExample\fP
.PP
.RS
.nf
<pidFile>/var/run/tntnet.pid</pidFile>
.fi
.RE
.PP
\fB\fC<queueSize>*number*</queueSize>\fR
.IP
Tntnet has a request\-queue, where new requests wait for service. This sets a
maximum size of this queue, after wich new requests are not accepted.
.IP
The default value is 1000.
.IP
\fIExample\fP
.PP
.RS
.nf
<queueSize>50</queueSize>
.fi
.RE
.PP
\fB\fC<sessionTimeout>*seconds*</sessionTimeout>\fR
.IP
This sets the number of seconds without requests after which a sesssion is
timed out.
.IP
The default value is 300 seconds.
.IP
\fIExample\fP
.PP
.RS
.nf
<sessionTimeout>600</sessionTimeout>
.fi
.RE
.PP
\fB\fC<socketReadTimeout>*milliseconds*</socketReadTimeout>\fR
.IP
A worker\-thread waits for some milliseconds on incoming data. If there is no
data, the job is put into a queue and another thread waits with 
.BR poll (2) 
on
incoming data on multiple sockets. The workerthreads are freed and they can
respond to other requests quickly. The default value is 10 milliseconds, which
is good for normal operation. A value of 0 results in non\-blocking read. If
timeout is reached, this does not mean, that the socket is closed. A small
timeout reduces contextswitches on slow connections.
.IP
\fIExample\fP
.PP
.RS
.nf
<socketReadTimeout>0</socketReadTimeout>
.fi
.RE
.PP
\fB\fC<socketWriteTimeout>*milliseconds*</socketWriteTimeout>\fR
.IP
This defines the time, how long the workerthreads wait on write.  If the
timeout is exceeded, the socket is closed and the browser might not get all
data.  The default value is 10000 milliseconds.
.IP
\fIExample\fP
.PP
.RS
.nf
<socketWriteTimeout>20000</socketWriteTimeout>
.fi
.RE
.PP
\fB\fC<threadStartDelay>*ms*</threadStartDelay>\fR
.IP
When additional worker threads are needed tntnet waits the number of
milliseconds before it starts additional threads to prevent high load when
starting many threads at once.
.IP
The default value is 10ms.
.IP
\fIExample\fP
.PP
.RS
.nf
<threadStartDelay>1000</threadStartDelay>
.fi
.RE
.PP
\fB\fC<user>*username*</user>\fR
.IP
Changes the user under which tntnet answers requests.
.IP
The user is changes using the system call 
.BR setuid (2), 
which is only allowed,
when tntnet starts as root user.
.IP
\fIExample\fP
.PP
.RS
.nf
<user>www-data</user>
.fi
.RE
.SH Urlmapping
.PP
TODO
.SH Listeners
.PP
TODO
.SH AUTHOR
.PP
This manual page was written by Tommi Mäkitalo 
.MT tommi@tntnet.org
.ME .
.SH SEE ALSO
.PP
tntnet (1)

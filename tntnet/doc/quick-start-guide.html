<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Tntnet Quick Start Guide</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.3  (Linux)">
	<META NAME="CREATED" CONTENT="20041208;21290800">
	<META NAME="CHANGED" CONTENT="20041211;22064000">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Tntnet Quick Start</H1>
<P>This is a quick-start-guide for tntnet. Tntnet has may features,
which I want to present here in short paragraphs to get them running
at your own system.</P>
<P>Warning: This guide is incomplete.</P>
<P>Tntnet is developed and tested with linux. It might work with
other unix or unix-like operating-systems, but this is not tested
yet.</P>
<H2>Installation</H2>
<P>For tntnet we need cxxtools first. Before installing cxxtools I
recomend to install lib4cplus first.</P>
<P>Download lib4cplus from <A HREF="http://sourceforge.net/projects/log4cplus/">http://sourceforge.net/projects/log4cplus/</A>
and install it with:</P>
<PRE>tar xzf log4cplus-1.0.2.tar.gz
cd log4cplus-1.0.2
./configure
make
su -c 'make install'</PRE><P>
You don't need log4cplus, but it is much better than the
cxxtools-built-in logger. Cxxtools has this built-in-logger just in
case you don't have log4cplus. “configure
CPPFLAGS=-I/usr/local/include” might help then.</P>
<P>You find cxxtools on my homepage
<A HREF="http://www.tntnet.org/download.bhtm">http://www.tntnet.org/download.bhtm</A>
and install it with:</P>
<PRE>tar xzf cxxtools-1.2.1.tar.gz
cd cxxtools-1.2.1
./configure
make
su -c 'make install'</PRE><P>
You should check the output of configure, if log4cplus is really used
(unless you choose not to use it). It warns, if it don't find
log4cplus.</P>
<P>Same installation-procedure with tntnet. Install it with:</P>
<PRE>tar xzf tntnet-1.2.1.tar.gz
cd tntnet-1.2.1
./configure
make
su -c 'make install'</PRE><P>
If everything went without errors, we should have a working tntnet.</P>
<H2>Creating a Webapplication</H2>
<P>To create a Webapplication you need to create:</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">a source-file with your
	application 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">a configurationfile 
	</P>
	<LI><P>a property-file for logging-configuration</P>
</UL>
<P>Create a ecpp-file <I>test.ecpp</I> with embedded c++ like this:</P>
<PRE>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;my first tntnet-application&lt;/h1&gt;
&lt;p&gt;1+3=&lt;$ 1+3 $&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE><P>
The configurationfile tells the tntnet-server, where to listen for
incoming requests and which component to execute at which url. Create
a file called <I>tntnet.conf</I>. It looks like this:</P>
<PRE>MapUrl /test.html    test@test
Listen 0.0.0.0 8000
PropertyFile tntnet.properties</PRE><P>
This tells tntnet, that whenever it receives a request to the url
/test.html, load the component <I>test</I> in the module <I>test</I>.</P>
<P>The Property-file <I>tntnet.properties</I> tells tntnet, where to
log requests and other useful informations:</P>
<PRE>log4cplus.rootLogger=INFO, STDOUT
log4cplus.appender.STDOUT=log4cplus::ConsoleAppender
log4cplus.appender.STDOUT.layout=log4cplus::TTCCLayout
log4cplus.appender.STDOUT.ImmediateFlush=true</PRE><P>
You need to compile and link your application. Normally you would
create a Makefile, but we do it by hand this time. Execute these
commands:</P>
<PRE>ecppc test.ecpp
g++ -c -fPIC test.cpp
g++ -o test.so -shared test.o -lecpp</PRE><P>
You should have a file <I>test.so</I> in your working-directory now.
This is your webapplication. Now start tntnet:</P>
<PRE STYLE="margin-bottom: 0.5cm">tntnet -c tntnet.conf</PRE><P>
It prints some lines on your terminal and waits now for requests.
Start a webbrowser and navigate to the page:
http://localhost:8000/test.html. You should see the page, you created
with the result of your difficult arithmetic operation.</P>
<P>The propertyfile enables standard-logging to the console.</P>
<P>What have we done?</P>
<P>Our webapplication is a simple web-page with special tags &lt;$
$&gt;. The ecppc-compiler creates a c++-source- and a header-file
with the same basename. Here is a class, which is named like the
file. You can look at it, if you want and sometimes it is useful to
read the generated code. Especially when the c++-compiler has
problems with your application. The linenumbers, the c++-compiler
prints out, when he finds a problem are from the cpp-file – not
from our ecpp-source. Luckily the generated code is well tested and
should not generate any problems, so you shouln't have any problems
identifying your code.</P>
<P>The tag &lt;$ tells the ecpp-compiler, that here starts a
c++-expression until it finds a $&gt;. The result of the expression
is printed into the resulting page, when the application is run.
Tntnet uses a std::ostream, so that the type of the result can be
anything, which have a outputoperator operator&lt;&lt;(ostream&amp;,
T) defined.</P>
<P>The configurationfile has 3 configurationvariables. “Listen”
tells tntnet the (local) IP-adress and port, where it should listen
for incoming requests. If you don't give tntnet a port, he listens on
port 80, which is normally only possible as root.</P>
<P>The variable “PropertyFile” tells the logger log4cplus, where
to find his configurationfile.</P>
<P>The entry “MapUrl” is for webapplications the most important
one. It tells tntnet what to do with incoming requests. Without it,
tntnet answeres to every request with http-error 404 – not found.
“MapUrl” maps the url, your webbrowser sends to a component. A
component is a piece of code, which is normally generated with ecpp.
That's what we did with test.ecpp. Components are identified by there
(class-)name and library. We named our class test and our shared
library test.so. The component-identifier is then test@test. This
“MapUrl” tells tntnet to call this component, when the url
/test.html is requested.</P>
<H2>Adding an image to your webapplication</H2>
<P>A nice webapplication is colorful and has some images. Lets add
one.</P>
<P>Create or fetch some picture. Say you have a picture <I>picture.jpg</I>.
Put it in your working-directory.</P>
<P>We modify our html-page test.ecpp to show a image first:</P>
<PRE>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;my first tntnet-application&lt;/h1&gt;
&lt;p&gt;1+3=&lt;$ 1+3 $&gt;&lt;/p&gt;
&lt;img src=”picture.jpg”&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE><P>
Next we compile the modified webpage and the picture and link
everithing together. We need to tell the ecpp-compiler ecppc, that it
is a binary file and which mime-type to generate. The flag -b tells
ecppc not to look for tags like &lt;$...$&gt;. The component needs to
tell the browser the mime-type. The file picture.jpg has the
mime-type image/jpeg. We tell it ecppc with the argument -m, so it
can compile it into the component.</P>
<PRE>ecppc test.ecpp
g++ -c -fPIC test.cpp
ecppc -b -m image/jpeg picture.jpg
g++ -c -fPIC picture.cpp
g++ -o test.so -shared test.o picture.o -lecpp</PRE><P>
Before we start tntnet, we have to extend our configuration. Tntnet
needs to know, that picture.jpg is found in the shared library. Our
new tntnet.conf looks like this:</P>
<PRE>MapUrl /test.html    test@test
MapUrl /picture.jpg    picture@test
Listen 0.0.0.0 8000
PropertyFile tntnet.properties</PRE><P>
We have a new webapplication in test.so. Start tntnet like before and
look at our page with your image.</P>
<H2>Create a Makefile for easier development</H2>
<P>Running the various compilers by hand gets boring and is
error-prone. As you can see, we need for this very simple
webapplication 5 compile-steps. Fortunately there is a tool, which
help us: make.</P>
<P>We create a file named Makefile for our application:</P>
<PRE>OBJECTS=test.o picture.o
CC=g++
CXXFLAGS=-fPIC

%.cpp %.h: %.ecpp
   ecppc $&lt;

%.cpp %.h: %.jpg
   ecppc -b -m image/jpeg $&lt;

test.so: $(OBJECTS)
   g++ -o $@ -shared -lecpp $^</PRE><P>
Be careful to use real tabs in indentation.</P>
<P>Now we can just call make every time, we modify our sources. It
compiles every file, which is newer as the target.</P>
<H2>Generalise our configuration</H2>
<P>When adding new pages to our application we have to be aware, that
tntnet finds the components. Until now we have added each component
into our configuration tntnet.conf. We can generalise it by using
regular expressions. We modify our configuration to look like this:</P>
<PRE>MapUrl /(.*).html     $1@test
MapUrl /(.*).jpg      $1@test
Listen 0.0.0.0 8000
PropertyFile tntnet.properties</PRE><P>
Now when your browser requests a page, tntnet looks for a matching
regular expression until it finds a matching one. Every request with
the suffix .html or .jpg looks for a component with the basename of
our request. Ok – there is one funny thing in our configuration: we
get our picture with http://localhost:8000/picture.html. But tntnet
does not care and nor does our browser. So we don't need to care
really.</P>
<H2>Adding some C++-processing</H2>
<P>Tntnet is for writing webapplications in C++. In the first example
you saw already one type of tag: &lt;$...$&gt;. This encloses a
C++-expression, which is evaluated and printed on your page.</P>
<P>Often we need to do some processing like fetching data from a
database or something. This can also happen on our ecpp-page. The
tags &lt;{...}&gt; enclose a C++-processing-block. We can enter
C++-code, which is just executed, when a browser fetches the page.</P>
<P>As a short form you can put the character '%' in the first column,
which means, that the rest of the line is C++.</P>
<P>We change our test.ecpp to look like that:</P>
<PRE>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;my first tntnet-application&lt;/h1&gt;
&lt;{
  // we have a c++-block here
  double arg1 = 1.0;
  double arg2 = 3.0;
  double result = arg1 + arg2
}&gt;
&lt;p&gt;
 &lt;$ arg1 $&gt; + &lt;$ arg2 $&gt; =
% if (result == 0.0) {
 nothing
% } else {
&lt;$ result $&gt;
% }
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE><P>
Compile and run the application with:</P>
<PRE>make
tntnet -c tntnet.conf
</PRE><P>
Maybe we should call it calc.ecpp. Sounds like a better name for our
little calculator.</P>
<P>But to be a real calculator the user should be able to enter the
values. It would be a funny application, if we need to compile it
every time, we need to add other values.</P>
<P>There is a solution to this, so go on reading.</P>
<H2>Processing parameters</H2>
<P>Html has forms for it. Forms send there values to a
webapplication, which can react to these. We need to receive
parameters from the application. Fortunately tntnet helps us here. We
use the ecpp-tags &lt;%args&gt; and &lt;/%args&gt;. They enclose a
parameterdefinition.</P>
<P>We start with a simple example:</P>
<PRE>&lt;%args&gt;
namefield
&lt;/%args&gt;
&lt;html&gt;&lt;body&gt;
&lt;form&gt;
What's your name?
&lt;input type=”text” name=”namefield”&gt;
&lt;input type=”submit”&gt;
&lt;/form&gt;
&lt;hr&gt;
Hello &lt;$ namefield $&gt;
&lt;/body&gt;&lt;/html&gt;
</PRE><P>
We put just a variablename in this args-block. This defines a
variable of type std::string, which receives the value of our
parameter. The first time we call our application, there are no
parameters, so 'namefield' is the empty string. Compile and run the
application.</P>
<P>We can define some other default value by changing the definition
to:</P>
<PRE>&lt;%args&gt;
namefield = “World!”
&lt;/%args&gt;
</PRE><P>
Now the first time we call our application we get this famous “Hello
World!”-output (sorry that it took so long until you get it).</P>
<P>Now we have the instruments to create a slightly more functional
calculator:</P>
<PRE>&lt;%args&gt;
arg1
arg2
&lt;/%args&gt;
&lt;{
  double v1, v2;
  std::istringstream s1(arg1);
  s1 &gt;&gt; v1;
  std::istringstream s2(arg2);
  s2 &gt;&gt; v2;
}&gt;
&lt;html&gt;&lt;body&gt;
&lt;form&gt;
&lt;input type=”text” name=”arg1” value=”&lt;$arg1$&gt;”&gt;
+
&lt;input type=”text” name=”arg2” value=”&lt;$arg2$&gt;”&gt;
% if (s1 &amp;&amp; s2) { // if both input-streams were successful extracting values
= &lt;$ v1 + v2 $&gt;
% }
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
</PRE><H2>
Modularise a webapplication</H2>
<P>A great thing with tntnet is, that we can create webpages out of
building blocks, like subroutines. Just create smal html-snippets and
put them together into one big page. Lets do it. First we create a
menu. We create a file with the name menu.ecpp:</P>
<PRE>&lt;a href=”page1.html”&gt;Page 1&lt;/a&gt;&lt;br&gt;
&lt;a href=”page2.html”&gt;Page 2&lt;/a&gt;&lt;br&gt;
&lt;a href=”page3.html”&gt;Page 3&lt;/a&gt;&lt;br&gt;
&lt;a href=”page4.html”&gt;Page 4&lt;/a&gt;&lt;br&gt;</PRE><P>
We create 4 pages <I>page1.html </I>to <I>page4.html </I>with some
content. Because we want our menu on each of our pages, we embed this
menu-component there. Here is page 1:</P>
<PRE>&lt;html&gt;
&lt;body&gt;
&lt;table&gt;
 &lt;tr&gt;
  &lt;td&gt;&lt;&amp; “menu” &amp;&gt;&lt;/td&gt;
  &lt;td&gt;&lt;h1&gt;Here ist page 1&lt;/h1&gt;&lt;/td&gt;
 &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE><P>
It should not be too hard to derive page 2 to 4 from here. Our
Makefile looks like this:</P>
<PRE>OBJECTS=page1.o page2.o page3.o page4.o menu.o
CC=g++
CXXFLAGS=-fPIC

%.cpp %.h: %.ecpp
   ecppc $&lt;

pages.so: $(OBJECTS)
   g++ -o $@ -shared -lecpp $^</PRE><P>
The configuration does not differ too much from our first example.
Just replace @test with @pages, because our modules name is now
pages.so instead of test.so.</P>
<P>A “make” will compile it and as usual tntnet -c tntnet.conf
runs it.</P>
<P>A block starting &lt;&amp; and ending &amp;&gt; contains a
subcomponent-call. In our simple case we have a normal
c++-string-constant here. It can be also a variable or a
functioncall, which returns a string (a std::string – we use stl
where we can).</P>
<H2>Using parameters</H2>
<P>When writing webapplications you normally have some forms, which
are filled and your webapplication need to do something with this
data.</P>
</BODY>
</HTML>
/** \page howto_upload HowtoHttpUpload

@htmlinclude sidebar.html

\htmlonly
<div id="content">

<h2>HTTP-upload</h2>

<p>This document describes, how to upload files with Tntnet.</p>

<p>Sometimes there is a need for uploading files to the webapplication. This is done with a special html-input-element of type "file". The form-element needs to specify an enctype of with the parameter "multipart/form-data". This enctype changes the way, form-data is sent to your webapplication. Luckily Tntnet handles all difficult stuff for you and fill your aruments specified in &lt;%args&gt;-sections.
</p>

<p>But with upload files the situation is a little different. First the file-data might be quite large and in would be not the most efficient way to put the data into a std::string like other arguments. The second problem is, that the file might have a additional attribute - the filename. Therefore Tntnet has a special API to handle this uploaded data.
</p>

<p>The data comes in a special multipart-structure, which is represented in Tntnet by the class tnt::Multipart. This has references to all query-parameters including uploaded files.
</p>

<p>You get a const reference to this multipart-object with the method getMultipart() of your request-object. Within this multipart-object you can find your file with the method find(partName). The parameter partName is the same name, you gave your upload-field in your html-form. You get a tnt::Multipart::const_iterator to the part. If the file is not found, the iterator points to the end-iterator retrieved with request.getMultipart().end(). If found, the dereferenced iterator is a reference to a tnt::Part-object, which represents your uploaded file.
You can ask for the mime-type with tnt::Part::getMimetype() and for the filename with tnt::Part::getFilename().
</p>

<p>The simplest way to fetch the data is to call tnt::Part::getBody(). You get the data as a std::string. But this is not very efficient, because Tntnet needs instantiate a std::string and copy the data. There is a iterator-interface for this. tnt::Part defines a const_iterator. Iterators to the start of your body is fetched with the getBodyBegin() and part the end with getBodyEnd(). If you don't need a std::string this is more efficient.
</p>

<p>This all sounds very complicated, but I hope it gets a little clearer, when you see a example.</p>

<p>The form looks like this:</p>

<pre class="sourcecode">
&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
 &lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;
 &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</pre>

<p>And the code to process the uploaded file:</p>

<pre class="sourcecode">
  &lt;%cpp&gt;
<pre><tt>  <b><font color="#0000FF">const</font></b> tnt<font color="#990000">::</font>Multipart<font color="#990000">&amp;</font> mp <font color="#990000">=</font> request<font color="#990000">.</font><b><font color="#000000">getMultipart</font></b><font color="#990000">();</font>
  tnt<font color="#990000">::</font>Multipart<font color="#990000">::</font>const_iterator it <font color="#990000">=</font> mp<font color="#990000">.</font><b><font color="#000000">find</font></b><font color="#990000">(</font><font color="#FF0000">"myfile"</font><font color="#990000">);</font>
  <b><font color="#0000FF">if</font></b> <font color="#990000">(</font>it <font color="#990000">!=</font> mp<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">())</font>
  <font color="#FF0000">{</font>
    <i><font color="#9A1900">// we found a uploaded file - write it to some upload-area</font></i>
    std<font color="#990000">::</font>ofstream <b><font color="#000000">out</font></b><font color="#990000">(</font><font color="#FF0000">"upload/"</font> <font color="#990000">+</font> it<font color="#990000">-&gt;</font><b><font color="#000000">getFilename</font></b><font color="#990000">());</font>

    out <font color="#990000">&lt;&lt;</font> it<font color="#990000">-&gt;</font><b><font color="#000000">getBody</font></b><font color="#990000">();</font> <i><font color="#9A1900">// this is less efficient, because a temporary std::string</font></i>
                                <i><font color="#9A1900">// is created and the data is copied into it</font></i>

    <i><font color="#9A1900">// more efficient is the use of iterators:</font></i>
    <b><font color="#0000FF">for</font></b> <font color="#990000">(</font>tnt<font color="#990000">::</font>Part<font color="#990000">::</font>const_iterator pi <font color="#990000">=</font> it<font color="#990000">-&gt;</font><b><font color="#000000">getBodyBegin</font></b><font color="#990000">();</font> pi <font color="#990000">!=</font> it<font color="#990000">-&gt;</font><b><font color="#000000">getBodyEnd</font></b><font color="#990000">();</font> <font color="#990000">++</font>pi<font color="#990000">)</font>
      out <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font>pi<font color="#990000">;</font>

    <i><font color="#9A1900">// ... or using STL-algorithm and ostreambuf_iterator:</font></i>
    std<font color="#990000">::</font><b><font color="#000000">copy</font></b><font color="#990000">(</font>it<font color="#990000">-&gt;</font><b><font color="#000000">getBodyBegin</font></b><font color="#990000">(),</font>
              it<font color="#990000">-&gt;</font><b><font color="#000000">getBodyEnd</font></b><font color="#990000">(),</font>
              std<font color="#990000">::</font>ostreambuf_iterator<font color="#990000">&lt;</font><font color="#009900">char</font><font color="#990000">&gt;(</font>out<font color="#990000">));</font>
  <font color="#FF0000">}</font>
</tt></pre>
  &lt;/%cpp&gt;
</pre>

<p>You can find another example in the tntnet-package in sdk/demos/upload. The application is a little online-hexdumper for the web. The user can upload a file and see the first 1024 bytes as a hexdump.
</p>

</div>

\endhtmlonly

*/

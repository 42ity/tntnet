/** \page byteorder Byteorder  algorithms

@section OverviewByteorder Overview

The byteoder API consists of two layers. One layer is responsible for
swapping the byteorder of a type and the high-level API can be used to
convert from an exernal byteorder to the host byteorder.

@section SwappingTheByteorder Swapping the byteorder
The low-level API consists of a generic swab() function, which is able to
swap the byteorder of a type by bytewise copying. This works for all
bitwise copyable types. Though, for many types, byteorder sapping can be
implemented with better performance. Therefore overloads of swab() are
offered for plain data types such as uint16_t that use shift operations.

The swab() function can be overloaded for custom types as well. For example
the following struct can have an overloaded swab():

@code
struct value
{
    value(char a, uint16_t b, char c)
    : _a(a), _b(b), _c(c)
    char _a;
    uint16_t _b;
    char _c;
};

value swab(const value& val)
{
    return value(val._a, swab(val.b), val._c);
}
@endcode

@section ConvertingExternalByteorder Converting from external byteorder to the host byteorder
The low-level swab() algorithm is used by the high level functions for
external to host byteorder conversions, for example beToHost(). On a little
endian system this function needs to swap the byteorder, on a big endian
system this funtion should return the value unchanged. The macros PTV_LE
and PRV_BE define whether the code should be compiled for a little endian
or big endian machine and adjust the behaviour of the high-level conversion
functions. If a swab() algorithm is overloaded for a custom type it can
be directly used with the high level functions:

@code
// some value in big endian byteorder
value beVal = getBeValue();

// convert to host byteorder
value hostVal = beToHost(beVal);
@endcode
*/
